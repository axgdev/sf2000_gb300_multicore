#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdarg.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <time.h>
#include <ctype.h>
#include <math.h>
#include "debug.h"
#include "hal.h"
#include "dirent.h"
#include <time.h>
#include <ctype.h>
#include <math.h>

// NOTE: cache flushing for a specific memory range is currently not stable!
/*
void cache_flush(void *addr, size_t size)
{
	uintptr_t idx;
	uintptr_t begin = (uintptr_t)addr;
	uintptr_t end = begin + size - 1;

    // Hit_Writeback_D
    for (idx = begin; idx <= end; idx += 16)
        asm volatile("cache 0x19, 0(%0)" : : "r"(idx));
    asm volatile("sync 0; nop; nop");
    // Hit_Invalidate_I
    for (idx = begin; idx <= end; idx += 16)
        asm volatile("cache 0x10, 0(%0)" : : "r"(idx));
    asm volatile("nop; nop; nop; nop; nop; nop; nop; nop"); // ehb may be nop on this core
}*/

void full_cache_flush()
{
	unsigned idx;

	// Index_Writeback_Inv_D
	for (idx = 0x80000000; idx <= 0x80004000; idx += 16) // all of D-cache
		asm volatile("cache 1, 0(%0); cache 1, 0(%0)" : : "r"(idx));

	asm volatile("sync 0; nop; nop");

	// Index_Invalidate_I
	for (idx = 0x80000000; idx <= 0x80004000; idx += 16) // all of I-cache
		asm volatile("cache 0, 0(%0); cache 0, 0(%0)" : : "r"(idx));

	asm volatile("nop; nop; nop; nop; nop"); // ehb may be nop on this core
}

// a call to this function is generated by gcc when __builtin__clear_cache is used
void _flush_cache(void *buf, size_t sz, int flags)
{
	// note: params are ignored and *all* the cache is cleared instead.
	// this seems to produce the most stable behavior for running dynarec code.

	full_cache_flush();
}

extern int g_errno;

extern void (*__xlog)(const char *fmt, ...);
// #define __xlog(...)

// Memory Allocation
void *malloc(size_t size) { return g_stock_api.malloc(size); }
void free(void *ptr) { g_stock_api.free(ptr); }
void *realloc(void *ptr, size_t size) { return g_stock_api.realloc(ptr, size); }
void *calloc(size_t nmemb, size_t size) { return g_stock_api.calloc(nmemb, size); }

void *sbrk(ptrdiff_t incr);

// String Manipulation
int strcat(char *dest, const char *src) { return g_stock_api.strcat(dest, src); }
int strncmp(const char *s1, const char *s2, size_t n) { return g_stock_api.strncmp(s1, s2, n); }
char *strncpy(char *dest, const char *src, size_t n) { return g_stock_api.strncpy(dest, src, n); }
char *strchr(const char *s, int c) { return g_stock_api.strchr(s, c); }
char *strrchr(const char *s, int c) { return g_stock_api.strrchr(s, c); }
char *strstr(const char *haystack, const char *needle) { return g_stock_api.strstr(haystack, needle); }
int strcasecmp(const char *s1, const char *s2) { return g_stock_api.strcasecmp(s1, s2); }
int strncasecmp(const char *s1, const char *s2, size_t n) { return g_stock_api.strncasecmp(s1, s2, n); }
void *memchr(const void *s, int c, size_t n) { return g_stock_api.memchr(s, c, n); }
void *memcpy(void *dest, const void *src, size_t n) { return g_stock_api.memcpy(dest, src, n); }
void *memset(void *s, int c, size_t n) { return g_stock_api.memset(s, c, n); }
int memcmp(const void *s1, const void *s2, size_t n) { return g_stock_api.memcmp(s1, s2, n); }
void *memmove(void *dest, const void *src, size_t n) { return g_stock_api.memmove(dest, src, n); }
char *strcpy(char *dest, const char *src) { return g_stock_api.strcpy(dest, src); }
int strcmp(const char *s1, const char *s2) { return g_stock_api.strcmp(s1, s2); }
size_t strlen(const char *s) { return g_stock_api.strlen(s); }
char *strdup(const char *s) { return g_stock_api.strdup(s); }

// Character Classification/Conversion
int tolower(int c) { return g_stock_api.tolower(c); }
int toupper(int c) { return g_stock_api.toupper(c); }
int isalnum(int c) { return g_stock_api.isalnum(c); }
int isalpha(int c) { return g_stock_api.isalpha(c); }
int isascii(int c) { return g_stock_api.isascii(c); }
int iscntrl(int c) { return g_stock_api.iscntrl(c); }
int isdigit(int c) { return g_stock_api.isdigit(c); }
int isgraph(int c) { return g_stock_api.isgraph(c); }
int islower(int c) { return g_stock_api.islower(c); }
int isprint(int c) { return g_stock_api.isprint(c); }
int ispunct(int c) { return g_stock_api.ispunct(c); }
int isspace(int c) { return g_stock_api.isspace(c); }
int isupper(int c) { return g_stock_api.isupper(c); }
int isxdigit(int c) { return g_stock_api.isxdigit(c); }
int toascii(int c) { return g_stock_api.toascii(c); }
int _tolower(int c) { return g_stock_api._tolower(c); }
int _toupper(int c) { return g_stock_api._toupper(c); }

// Numeric Conversion
long int strtol(const char *nptr, char **endptr, int base) { return g_stock_api.strtol(nptr, endptr, base); }
unsigned long int strtoul(const char *nptr, char **endptr, int base) { return g_stock_api.strtoul(nptr, endptr, base); }
double strtod(const char *nptr, char **endptr) { return g_stock_api.strtod(nptr, endptr); }
int atoi(const char *nptr) { return g_stock_api.atoi(nptr); }

// Memory Allocation
void *malloc(size_t size) { return g_stock_api.malloc(size); }
void free(void *ptr) { return g_stock_api.free(ptr); }
void *realloc(void *ptr, size_t size) { return g_stock_api.realloc(ptr, size); }
void *calloc(size_t nmemb, size_t size) { return g_stock_api.calloc(nmemb, size); }

void *sbrk(ptrdiff_t incr)
{
	static void *s_heap_end;
	static void *s_heap_ptr = NULL;
	if (!s_heap_ptr)
	{
		s_heap_ptr = *g_stock_api.gp_buf_64m;
		s_heap_end = *g_stock_api.gp_buf_64m + 0x4000000;
	}

	void *curr_ptr = s_heap_ptr;
	void *new_ptr = s_heap_ptr + incr;

	if (new_ptr >= s_heap_end)
		lcd_bsod("sbrk: out of memory");

	s_heap_ptr = new_ptr;

// __xlog("sbrk: ret=%p incr=%d s_heap_ptr=%p
", curr_ptr, (int)incr, s_heap_ptr);
	
	return curr_ptr;
}

// Formatted I/O
int vsnprintf(char *str, size_t size, const char *format, va_list ap) { return g_stock_api.vsnprintf(str, size, format, ap); }
int sprintf(char *str, const char *format, ...) {
    va_list args;
    va_start(args, format);
    int ret = g_stock_api.vsprintf(str, format, args);
    va_end(args);
    return ret;
}
int vprintf(const char *format, va_list ap) { return g_stock_api.vprintf(format, ap); }
int printf(const char *format, ...) {
    va_list args;
    va_start(args, format);
    int ret = g_stock_api.vprintf(format, args);
    va_end(args);
    return ret;
}
int snprintf(char *str, size_t size, const char *format, ...) {
    va_list args;
    va_start(args, format);
    int ret = g_stock_api.vsnprintf(str, size, format, args);
    va_end(args);
    return ret;
}
int vsprintf(char *str, const char *format, va_list ap) { return g_stock_api.vsprintf(str, format, ap); }
int vsscanf(const char *str, const char *format, va_list ap) { return g_stock_api.vsscanf(str, format, ap); }
int sscanf(const char *str, const char *format, ...) {
    va_list args;
    va_start(args, format);
    int ret = g_stock_api.vsscanf(str, format, args);
    va_end(args);
    return ret;
}

// File I/O (FILE* based)
int fclose(FILE *fp) { return g_stock_api.fclose(fp); }
int fflush(FILE *fp) { return g_stock_api.fflush(fp); }
FILE *fopen(const char *path, const char *mode) { return g_stock_api.fopen(path, mode); }
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) { return g_stock_api.fw_fread(ptr, size, nmemb, stream); }
int fseeko(FILE *stream, off_t offset, int whence) { return g_stock_api.fseeko(stream, offset, whence); }
long ftell(FILE *stream) { return g_stock_api.ftell(stream); }
off_t ftello(FILE *stream) { return g_stock_api.ftello(stream); }
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) { return g_stock_api.fwrite(ptr, size, nmemb, stream); }
char *fgets(char *s, int size, FILE *stream) { return g_stock_api.fgets(s, size, stream); }

// Time
time_t time(time_t *t) { return g_stock_api.time(t); }
struct tm *localtime(const time_t *timep) { return g_stock_api.localtime(timep); }

// Miscellaneous
int rand(void) { return g_stock_api.rand(); }
int isnan(double x) { return g_stock_api.isnan(x); }
int isinf(double x) { return g_stock_api.isinf(x); }

// String Manipulation
int strcat(char *dest, const char *src) { return g_stock_api.strcat(dest, src); }
int strncmp(const char *s1, const char *s2, size_t n) { return g_stock_api.strncmp(s1, s2, n); }
char *strncpy(char *dest, const char *src, size_t n) { return g_stock_api.strncpy(dest, src, n); }
char *strchr(const char *s, int c) { return g_stock_api.strchr(s, c); }
char *strrchr(const char *s, int c) { return g_stock_api.strrchr(s, c); }
char *strstr(const char *haystack, const char *needle) { return g_stock_api.strstr(haystack, needle); }
int strcasecmp(const char *s1, const char *s2) { return g_stock_api.strcasecmp(s1, s2); }
int strncasecmp(const char *s1, const char *s2, size_t n) { return g_stock_api.strncasecmp(s1, s2, n); }
void *memchr(const void *s, int c, size_t n) { return g_stock_api.memchr(s, c, n); }
void *memcpy(void *dest, const void *src, size_t n) { return g_stock_api.memcpy(dest, src, n); }
void *memset(void *s, int c, size_t n) { return g_stock_api.memset(s, c, n); }
int memcmp(const void *s1, const void *s2, size_t n) { return g_stock_api.memcmp(s1, s2, n); }
void *memmove(void *dest, const void *src, size_t n) { return g_stock_api.memmove(dest, src, n); }
char *strcpy(char *dest, const char *src) { return g_stock_api.strcpy(dest, src); }
int strcmp(const char *s1, const char *s2) { return g_stock_api.strcmp(s1, s2); }
size_t strlen(const char *s) { return g_stock_api.strlen(s); }
char *strdup(const char *s) { return g_stock_api.strdup(s); }

// Character Classification/Conversion
int tolower(int c) { return g_stock_api.tolower(c); }
int toupper(int c) { return g_stock_api.toupper(c); }
int isalnum(int c) { return g_stock_api.isalnum(c); }
int isalpha(int c) { return g_stock_api.isalpha(c); }
int isascii(int c) { return g_stock_api.isascii(c); }
int iscntrl(int c) { return g_stock_api.iscntrl(c); }
int isdigit(int c) { return g_stock_api.isdigit(c); }
int isgraph(int c) { return g_stock_api.isgraph(c); }
int islower(int c) { return g_stock_api.islower(c); }
int isprint(int c) { return g_stock_api.isprint(c); }
int ispunct(int c) { return g_stock_api.ispunct(c); }
int isspace(int c) { return g_stock_api.isspace(c); }
int isupper(int c) { return g_stock_api.isupper(c); }
int isxdigit(int c) { return g_stock_api.isxdigit(c); }
int toascii(int c) { return g_stock_api.toascii(c); }
int _tolower(int c) { return g_stock_api._tolower(c); }
int _toupper(int c) { return g_stock_api._toupper(c); }

// Numeric Conversion
long int strtol(const char *nptr, char **endptr, int base) { return g_stock_api.strtol(nptr, endptr, base); }
unsigned long int strtoul(const char *nptr, char **endptr, int base) { return g_stock_api.strtoul(nptr, endptr, base); }
double strtod(const char *nptr, char **endptr) { return g_stock_api.strtod(nptr, endptr); }
int atoi(const char *nptr) { return g_stock_api.atoi(nptr); }

// Formatted I/O
int vsnprintf(char *str, size_t size, const char *format, va_list ap) { return g_stock_api.vsnprintf(str, size, format, ap); }
int sprintf(char *str, const char *format, ...) {
    va_list args;
    va_start(args, format);
    int ret = g_stock_api.vsprintf(str, format, args);
    va_end(args);
    return ret;
}
int vprintf(const char *format, va_list ap) { return g_stock_api.vprintf(format, ap); }
int printf(const char *format, ...) {
    va_list args;
    va_start(args, format);
    int ret = g_stock_api.vprintf(format, args);
    va_end(args);
    return ret;
}
int snprintf(char *str, size_t size, const char *format, ...) {
    va_list args;
    va_start(args, format);
    int ret = g_stock_api.vsnprintf(str, size, format, args);
    va_end(args);
    return ret;
}
int vsprintf(char *str, const char *format, va_list ap) { return g_stock_api.vsprintf(str, format, ap); }
int vsscanf(const char *str, const char *format, va_list ap) { return g_stock_api.vsscanf(str, format, ap); }
int sscanf(const char *str, const char *format, ...) {
    va_list args;
    va_start(args, format);
    int ret = g_stock_api.vsscanf(str, format, args);
    va_end(args);
    return ret;
}

// File I/O (FILE* based)
int fclose(FILE *fp) { return g_stock_api.fclose(fp); }
int fflush(FILE *fp) { return g_stock_api.fflush(fp); }
FILE *fopen(const char *path, const char *mode) { return g_stock_api.fopen(path, mode); }
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream) { return g_stock_api.fw_fread(ptr, size, nmemb, stream); }
int fseeko(FILE *stream, off_t offset, int whence) { return g_stock_api.fseeko(stream, offset, whence); }
long ftell(FILE *stream) { return g_stock_api.ftell(stream); }
off_t ftello(FILE *stream) { return g_stock_api.ftello(stream); }
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream) { return g_stock_api.fwrite(ptr, size, nmemb, stream); }
char *fgets(char *s, int size, FILE *stream) { return g_stock_api.fgets(s, size, stream); }

// Time
time_t time(time_t *t) { return g_stock_api.time(t); }
struct tm *localtime(const time_t *timep) { return g_stock_api.localtime(timep); }

// Miscellaneous
int rand(void) { return g_stock_api.rand(); }
int isnan(double x) { return g_stock_api.isnan(x); }
int isinf(double x) { return g_stock_api.isinf(x); }

// File I/O (fd based)
int open(const char *path, int flags, ...)

int open(const char *path, int flags, ...)
{
	int fs_flags = 0;
	int fs_perms = 0666;    // all access?
	
	if (flags & O_RDONLY) fs_flags |= FS_O_RDONLY;
	if (flags & O_WRONLY) fs_flags |= FS_O_WRONLY;
	if (flags & O_RDWR)   fs_flags |= FS_O_RDWR;
	if (flags & O_APPEND) fs_flags |= FS_O_APPEND;
	if (flags & O_CREAT)  fs_flags |= FS_O_CREAT;
	if (flags & O_TRUNC)  fs_flags |= FS_O_TRUNC;

// __xlog("open: path=%s flags=%d fs_flags=%d\n", path, flags, fs_flags);

int ret = g_stock_api.fs_open(path, fs_flags, fs_perms);
	if (ret < 0)
		errno = *g_stock_api.g_errno;
	else
		ret += 5;

// __xlog("open: ret=%d\n", ret);
	return ret;
}

ssize_t read(int fd, void *buf, size_t count)
{
if (fd == 0 || fd == 1 || fd == 2)
		return 0;

	fd -= 5;

// __xlog("read: fd=%d buf=%p count=%u\n", fd, buf, count);
	ssize_t ret = g_stock_api.fs_read(fd, buf, count);
	if (ret < 0)
		errno = *g_stock_api.g_errno;
// __xlog("read: ret=%d\n", ret);
	return ret;
}

ssize_t write(int fd, const void *buf, size_t count)
{
	if (fd == 0)
		return -1;
	else if (fd == 1 || fd == 2)
	{
		xlog("%.*s", count, buf);
		return count;
	}

	fd -= 5;

// __xlog("write: fd=%d buf=%p count=%u\n", fd, buf, count);
	ssize_t ret = g_stock_api.fs_write(fd, buf, count);
	if (ret < 0)
		errno = *g_stock_api.g_errno;
// __xlog("write: ret=%d\n", ret);
	return ret;
}

off_t lseek(int fd, off_t offset, int whence)
{
	if (fd == 0 || fd == 1 || fd == 2)
		return -1;

// __xlog("lseek: fd=%d offset=%d whence=%d\n", fd, (int)offset, whence);

	fd -= 5;

	int64_t ret = g_stock_api.fs_lseek(fd, offset, whence);
	if (ret < 0)
		errno = *g_stock_api.g_errno;
// __xlog("lseek: ret=%d\n", (int)ret);

	return ret;
}

int close(int fd)
{
	if (fd == 0 || fd == 1 || fd == 2)
		return -1;

// __xlog("close: fd=%d\n", fd);

	fd -= 5;

	int ret = g_stock_api.fs_close(fd);
	if (ret < 0)
		errno = *g_stock_api.g_errno;
// __xlog("close: ret=%d\n", ret);
	return ret;
}

typedef struct {
	union {
		struct {
			uint8_t	_1[0x18];	// type is at offset 0x18
			uint32_t type;		// 0x81b6 - file,	0x41ff - dir
		};
		struct {
			uint8_t	_2[0x38];	// size is at offset 0x38
			uint32_t size;		// filesize if type is a file
		};
		uint8_t	__[160];		// total struct size is 160
	};
} fs_stat_t;

static int stat_common(int ret, fs_stat_t *buffer, struct stat *sbuf)
{
	if (ret == 0)
	{
		memset(sbuf, 0, sizeof(*sbuf));
		sbuf->st_mode = S_ISREG(buffer->type)*S_IFREG | S_ISDIR(buffer->type)*S_IFDIR | (S_IRUSR|S_IWUSR);
		sbuf->st_size = buffer->size;
		return 0;
	}
	else
		return -1;
}

// wrap fs_stat to supply a more standard stat implementation
// for now only `type` (for dir or file) and `size` fields of `struct stat` are filled
int	stat(const char *path, struct stat *sbuf)
{
	fs_stat_t buffer = {0};
	int ret = g_stock_api.fs_stat(path, &buffer);
	return stat_common(ret, &buffer, sbuf);
}

int	fstat(int fd, struct stat *sbuf)
{
	fs_stat_t buffer = {0};
	int ret = g_stock_api.fs_fstat(fd, &buffer);
	return stat_common(ret, &buffer, sbuf);
}

int access(const char *path, int mode)
{
    struct stat buffer;
    return stat(path, &buffer);
}

int mkdir(const char *path, mode_t mode)
{
	return g_stock_api.fs_mkdir(path, mode);
}

char *getcwd(char *buf, size_t size)
{
	return NULL;
}

int chdir(const char *path)
{
	return -1;
}

int rmdir(const char *path)
{
	return -1;
}

int unlink(const char *path)
{
	return -1;
}

int chmod(const char *path, mode_t mode)
{
	return -1;
}

int kill(pid_t pid, int sig)
{
	return -1;
}

pid_t getpid(void)
{
	return 1;
}

void abort(void)
{
	unsigned ra;
	asm volatile ("move %0, $ra" : "=r" (ra));
	g_stock_api.lcd_bsod("abort() called from 0x%08x", ra);
}

void exit(int status)
{
	unsigned ra;
	asm volatile ("move %0, $ra" : "=r" (ra));
	g_stock_api.lcd_bsod("exit(%d) called from 0x%08x", status, ra);
}

/* wrappers were not compiled in, but vfs drivers likely support these ops */
int rename(const char *old, const char* new)
{
	return -1;
}

int isatty(int fd)
{
    return 0;
}

clock_t clock(void)
{
	// clock function should return cpu clock ticks, so since os_get_tick_count() returns milliseconds,
	// we devide by 1000 to get the seconds and multiply by CLOCKS_PER_SEC to get the clock ticks.
    return (clock_t)(g_stock_api.os_get_tick_count() * CLOCKS_PER_SEC / 1000);
}

int gettimeofday(struct timeval *tv, void *tz)
{
	if (tv == NULL)
		return -1;

	uint32_t msec = g_stock_api.os_get_tick_count();

	tv->tv_sec = msec / 1000;
	tv->tv_usec = (msec % 1000) * 1000;

	return 0;
}

DIR *opendir(const char *path)
{
	int fd = g_stock_api.fs_opendir(path);
	if (fd < 0)
		return NULL;

	return (DIR*)(fd + 1);
}

int closedir(DIR *dir)
{
	int fd = (int)dir - 1;
	if (fd < 0)
		return -1;

	return g_stock_api.fs_closedir(fd);
}

struct dirent *readdir(DIR *dir)
{
	int fd = (int)dir - 1;
	if (fd < 0)
		return NULL;

	struct {
		union {
			struct {
				uint8_t _1[0x10];
				uint32_t type;
			};
			struct {
				uint8_t _2[0x22];
				char    d_name[0x225];
			};
			uint8_t __[0x428];
		};
	} buffer = {0};

	if (g_stock_api.fs_readdir(fd, &buffer) < 0)
		return NULL;

	// TODO: not thread safe
	static struct dirent d;

	d.d_type = S_ISREG(buffer.type)*DTYPE_FILE | S_ISDIR(buffer.type)*DTYPE_DIRECTORY;
	strncpy(d.d_name, buffer.d_name, sizeof(d.d_name));
	return &d;
}
